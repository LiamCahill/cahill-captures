{
  "version": 3,
  "sources": ["../../@convex-dev/sharded-counter/src/client/index.ts"],
  "sourcesContent": ["import {\n  DocumentByName,\n  Expand,\n  FunctionReference,\n  GenericDataModel,\n  GenericMutationCtx,\n  GenericQueryCtx,\n  TableNamesInDataModel,\n} from \"convex/server\";\nimport { GenericId } from \"convex/values\";\nimport { api } from \"../component/_generated/api\";\n\n/**\n * A sharded counter is a map from string -> counter, where each counter can\n * be incremented or decremented atomically.\n */\nexport class ShardedCounter<ShardsKey extends string> {\n  /**\n   * A sharded counter is a map from string -> counter, where each counter can\n   * be incremented or decremented.\n   *\n   * The counter is sharded into multiple documents to allow for higher\n   * throughput of updates. The default number of shards is 16.\n   *\n   * - More shards => higher throughput of updates.\n   * - Fewer shards => lower latency when querying the counter.\n   *\n   * @param options.shards The number of shards for each counter, for fixed\n   *   keys.\n   * @param options.defaultShards The number of shards for each counter, for\n   *   keys not in `options.shards`.\n   */\n  constructor(\n    private component: UseApi<typeof api>,\n    options?: {\n      shards?: Partial<Record<ShardsKey, number>>;\n      defaultShards?: number;\n    },\n  ) {\n    this.stickyShard = {};\n    const defaultShards = options?.defaultShards;\n    this.shardsForKey = (name: ShardsKey) => {\n      const explicitShards = options?.shards?.[name];\n      return explicitShards ?? defaultShards;\n    };\n  }\n\n  private shardsForKey: (name: ShardsKey) => number | undefined;\n\n  // Keep track of the shard for each key, so multiple mutations on the same key\n  // will use the same shard.\n  private stickyShard: Record<string, number>;\n\n  /**\n   * Increase the counter for key `name` by `count`.\n   * If `count` is negative, the counter will decrease.\n   *\n   * @param name The key to update the counter for.\n   * @param count The amount to increment the counter by. Defaults to 1.\n   */\n  async add<Name extends ShardsKey>(\n    ctx: RunMutationCtx,\n    name: Name,\n    count: number = 1,\n  ) {\n    const shard = await ctx.runMutation(this.component.public.add, {\n      name,\n      count,\n      shard: this.stickyShard?.[name],\n      shards: this.shardsForKey(name),\n    });\n    this.stickyShard[name] = shard;\n  }\n\n  /**\n   * Decrease the counter for key `name` by `count`.\n   */\n  async subtract<Name extends ShardsKey>(\n    ctx: RunMutationCtx,\n    name: Name,\n    count: number = 1,\n  ) {\n    return this.add(ctx, name, -count);\n  }\n\n  /**\n   * Increment the counter for key `name` by 1.\n   */\n  async inc<Name extends ShardsKey>(ctx: RunMutationCtx, name: Name) {\n    return this.add(ctx, name, 1);\n  }\n\n  /**\n   * Decrement the counter for key `name` by 1.\n   */\n  async dec<Name extends ShardsKey>(ctx: RunMutationCtx, name: Name) {\n    return this.add(ctx, name, -1);\n  }\n\n  /**\n   * Gets the counter for key `name`.\n   *\n   * NOTE: this reads from all shards. If used in a mutation, it will contend\n   * with all mutations that update the counter for this key.\n   */\n  async count<Name extends ShardsKey>(ctx: RunQueryCtx, name: Name) {\n    return ctx.runQuery(this.component.public.count, { name });\n  }\n\n  /**\n   * Redistribute counts evenly across the counter's shards.\n   *\n   * If there were more shards for this counter at some point, those shards\n   * will be removed.\n   *\n   * If there were fewer shards for this counter, or if the random distribution\n   * of counts is uneven, the counts will be redistributed evenly.\n   *\n   * This operation reads and writes all shards, so it can cause contention if\n   * called too often.\n   */\n  async rebalance<Name extends ShardsKey>(ctx: RunMutationCtx, name: Name) {\n    await ctx.runMutation(this.component.public.rebalance, {\n      name,\n      shards: this.shardsForKey(name),\n    });\n  }\n\n  /**\n   * Clear the counter for key `name`.\n   *\n   * @param name The key to clear the counter for.\n   */\n  async reset<Name extends ShardsKey>(ctx: RunMutationCtx, name: Name) {\n    await ctx.runMutation(this.component.public.reset, { name });\n  }\n\n  /**\n   * Estimate the count of a counter by only reading from a subset of shards,\n   * and extrapolating the total count.\n   *\n   * After a `rebalance`, or if there were a lot of data points to yield a\n   * random distribution across shards, this should be a good approximation of\n   * the total count. If there are few data points, which are not evenly\n   * distributed across shards, this will be a poor approximation.\n   *\n   * Use this to reduce contention when reading the counter.\n   */\n  async estimateCount<Name extends ShardsKey>(\n    ctx: RunQueryCtx,\n    name: Name,\n    readFromShards: number = 1,\n  ) {\n    return await ctx.runQuery(this.component.public.estimateCount, {\n      name,\n      shards: this.shardsForKey(name),\n      readFromShards,\n    });\n  }\n  /**\n   * Returns an object with methods to update and query the counter for key\n   * `name`. For fixed keys, you can call `counter.for(\"<key>\")` to get methods\n   * for updating or querying the counter for that key. Example:\n   *\n   * ```ts\n   * const counter = new ShardedCounter(components.shardedCounter);\n   * const beanCounter = counter.for(\"beans\");\n   * export const pushPapers = mutation({\n   *  handler: async (ctx) => {\n   *   await beanCounter.inc(ctx);\n   *  },\n   * });\n   * ```\n   */\n  for<Name extends ShardsKey>(name: Name) {\n    return {\n      /**\n       * Add `count` to the counter.\n       */\n      add: async (ctx: RunMutationCtx, count: number = 1) =>\n        this.add(ctx, name, count),\n      /**\n       * Subtract `count` from the counter.\n       */\n      subtract: async (ctx: RunMutationCtx, count: number = 1) =>\n        this.add(ctx, name, -count),\n      /**\n       * Increment the counter by 1.\n       */\n      inc: async (ctx: RunMutationCtx) => this.add(ctx, name, 1),\n      /**\n       * Decrement the counter by 1.\n       */\n      dec: async (ctx: RunMutationCtx) => this.add(ctx, name, -1),\n      /**\n       * Get the current value of the counter.\n       *\n       * NOTE: this reads from all shards. If used in a mutation, it will\n       * contend with all mutations that update the counter for this key.\n       */\n      count: async (ctx: RunQueryCtx) => this.count(ctx, name),\n      /**\n       * Reset the counter for this key.\n       */\n      reset: async (ctx: RunMutationCtx) => this.reset(ctx, name),\n      /**\n       * Redistribute counts evenly across the counter's shards.\n       *\n       * This operation reads and writes all shards, so it can cause contention\n       * if called too often.\n       */\n      rebalance: async (ctx: RunMutationCtx) => this.rebalance(ctx, name),\n      /**\n       * Estimate the counter by only reading from a subset of shards,\n       * and extrapolating the total count.\n       *\n       * Use this to reduce contention when reading the counter.\n       */\n      estimateCount: async (ctx: RunQueryCtx, readFromShards: number = 1) =>\n        this.estimateCount(ctx, name, readFromShards),\n    };\n  }\n  trigger<Ctx extends RunMutationCtx, Name extends ShardsKey>(\n    name: Name,\n  ): Trigger<Ctx, GenericDataModel, TableNamesInDataModel<GenericDataModel>> {\n    return async (ctx, change) => {\n      if (change.operation === \"insert\") {\n        await this.inc(ctx, name);\n      } else if (change.operation === \"delete\") {\n        await this.dec(ctx, name);\n      }\n    };\n  }\n}\n\n/* Type utils follow */\n\nexport type Trigger<\n  Ctx,\n  DataModel extends GenericDataModel,\n  TableName extends TableNamesInDataModel<DataModel>,\n> = (ctx: Ctx, change: Change<DataModel, TableName>) => Promise<void>;\n\nexport type Change<\n  DataModel extends GenericDataModel,\n  TableName extends TableNamesInDataModel<DataModel>,\n> = {\n  id: GenericId<TableName>;\n} & (\n  | {\n      operation: \"insert\";\n      oldDoc: null;\n      newDoc: DocumentByName<DataModel, TableName>;\n    }\n  | {\n      operation: \"update\";\n      oldDoc: DocumentByName<DataModel, TableName>;\n      newDoc: DocumentByName<DataModel, TableName>;\n    }\n  | {\n      operation: \"delete\";\n      oldDoc: DocumentByName<DataModel, TableName>;\n      newDoc: null;\n    }\n);\n\ntype RunQueryCtx = {\n  runQuery: GenericQueryCtx<GenericDataModel>[\"runQuery\"];\n};\ntype RunMutationCtx = {\n  runMutation: GenericMutationCtx<GenericDataModel>[\"runMutation\"];\n};\n\nexport type OpaqueIds<T> =\n  T extends GenericId<infer _T>\n    ? string\n    : T extends (infer U)[]\n      ? OpaqueIds<U>[]\n      : T extends object\n        ? { [K in keyof T]: OpaqueIds<T[K]> }\n        : T;\n\nexport type UseApi<API> = Expand<{\n  [mod in keyof API]: API[mod] extends FunctionReference<\n    infer FType,\n    \"public\",\n    infer FArgs,\n    infer FReturnType,\n    infer FComponentPath\n  >\n    ? FunctionReference<\n        FType,\n        \"internal\",\n        OpaqueIds<FArgs>,\n        OpaqueIds<FReturnType>,\n        FComponentPath\n      >\n    : UseApi<API[mod]>;\n}>;\n"],
  "mappings": ";;;;;AAgBM,IAAO,iBAAP,MAAqB;;;;;;;;;;;;;;;;EAgBzB,YACU,WACR,SAGC;AAJO;AAcF;AAIA;;;AAlBE,SAAA,YAAA;AAMR,SAAK,cAAc,CAAA;AACnB,UAAM,gBAAgB,mCAAS;AAC/B,SAAK,eAAe,CAAC,SAAmB;AA7B5C;AA8BM,YAAM,kBAAiB,wCAAS,WAAT,mBAAkB;AACzC,aAAO,kBAAkB;IAC3B;EACF;;;;;;;;EAeA,MAAM,IACJ,KACA,MACA,QAAgB,GAAC;AAnDrB;AAqDI,UAAM,QAAQ,MAAM,IAAI,YAAY,KAAK,UAAU,OAAO,KAAK;MAC7D;MACA;MACA,QAAO,UAAK,gBAAL,mBAAmB;MAC1B,QAAQ,KAAK,aAAa,IAAI;KAC/B;AACD,SAAK,YAAY,IAAI,IAAI;EAC3B;;;;EAKA,MAAM,SACJ,KACA,MACA,QAAgB,GAAC;AAEjB,WAAO,KAAK,IAAI,KAAK,MAAM,CAAC,KAAK;EACnC;;;;EAKA,MAAM,IAA4B,KAAqB,MAAU;AAC/D,WAAO,KAAK,IAAI,KAAK,MAAM,CAAC;EAC9B;;;;EAKA,MAAM,IAA4B,KAAqB,MAAU;AAC/D,WAAO,KAAK,IAAI,KAAK,MAAM,EAAE;EAC/B;;;;;;;EAQA,MAAM,MAA8B,KAAkB,MAAU;AAC9D,WAAO,IAAI,SAAS,KAAK,UAAU,OAAO,OAAO,EAAE,KAAI,CAAE;EAC3D;;;;;;;;;;;;;EAcA,MAAM,UAAkC,KAAqB,MAAU;AACrE,UAAM,IAAI,YAAY,KAAK,UAAU,OAAO,WAAW;MACrD;MACA,QAAQ,KAAK,aAAa,IAAI;KAC/B;EACH;;;;;;EAOA,MAAM,MAA8B,KAAqB,MAAU;AACjE,UAAM,IAAI,YAAY,KAAK,UAAU,OAAO,OAAO,EAAE,KAAI,CAAE;EAC7D;;;;;;;;;;;;EAaA,MAAM,cACJ,KACA,MACA,iBAAyB,GAAC;AAE1B,WAAO,MAAM,IAAI,SAAS,KAAK,UAAU,OAAO,eAAe;MAC7D;MACA,QAAQ,KAAK,aAAa,IAAI;MAC9B;KACD;EACH;;;;;;;;;;;;;;;;EAgBA,IAA4B,MAAU;AACpC,WAAO;;;;MAIL,KAAK,OAAO,KAAqB,QAAgB,MAC/C,KAAK,IAAI,KAAK,MAAM,KAAK;;;;MAI3B,UAAU,OAAO,KAAqB,QAAgB,MACpD,KAAK,IAAI,KAAK,MAAM,CAAC,KAAK;;;;MAI5B,KAAK,OAAO,QAAwB,KAAK,IAAI,KAAK,MAAM,CAAC;;;;MAIzD,KAAK,OAAO,QAAwB,KAAK,IAAI,KAAK,MAAM,EAAE;;;;;;;MAO1D,OAAO,OAAO,QAAqB,KAAK,MAAM,KAAK,IAAI;;;;MAIvD,OAAO,OAAO,QAAwB,KAAK,MAAM,KAAK,IAAI;;;;;;;MAO1D,WAAW,OAAO,QAAwB,KAAK,UAAU,KAAK,IAAI;;;;;;;MAOlE,eAAe,OAAO,KAAkB,iBAAyB,MAC/D,KAAK,cAAc,KAAK,MAAM,cAAc;;EAElD;EACA,QACE,MAAU;AAEV,WAAO,OAAO,KAAK,WAAU;AAC3B,UAAI,OAAO,cAAc,UAAU;AACjC,cAAM,KAAK,IAAI,KAAK,IAAI;iBACf,OAAO,cAAc,UAAU;AACxC,cAAM,KAAK,IAAI,KAAK,IAAI;;IAE5B;EACF;;",
  "names": []
}
